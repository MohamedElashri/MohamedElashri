name: Update latest GitHub activity

on:
  schedule:
    - cron: "41 */6 * * *"   # every 6 hours
  workflow_dispatch: {}
  push:
    paths:
      - .github/workflows/update-github-activity.yml

jobs:
  activity:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      USERNAME: "MohamedElashri"
      MAX_ITEMS: "10"
      TARGET_FILE: "README.md"
      START_MARKER: "<!-- ACTIVITY:START -->"
      END_MARKER: "<!-- ACTIVITY:END -->"
      MAX_LOOKBACK_DAYS: "60"   # ignore events older than this window
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate activity block
        uses: actions/github-script@v7
        id: gen
        with:
          script: |
            const username = process.env.USERNAME;
            const maxItems = parseInt(process.env.MAX_ITEMS || "10", 10);
            const maxLookbackDays = parseInt(process.env.MAX_LOOKBACK_DAYS || "60", 10);
            const cutoff = new Date(Date.now() - maxLookbackDays * 24 * 60 * 60 * 1000);

            // Fetch recent public events
            const perPage = 100;
            const events = await github.request("GET /users/{username}/events/public", {
              username,
              per_page: perPage
            }).then(r => r.data);

            // Only keep substantive, professional signals
            const allowed = new Set([
              "PullRequestEvent",
              "PullRequestReviewEvent",
              "PullRequestReviewCommentEvent",
              "IssuesEvent",
              "IssueCommentEvent",
              "CommitCommentEvent",
              "ReleaseEvent",
              "PushEvent"
            ]);

            // Optional helper: truncate long text
            const truncate = (s, n = 80) => {
              if (!s) return "";
              const one = s.split("\n")[0].trim();
              return one.length > n ? one.slice(0, n - 1) + "â€¦" : one;
            };

            function repoUrl(full) { return `https://github.com/${full}`; }
            function prUrl(repo, num) { return `https://github.com/${repo}/pull/${num}`; }
            function issueUrl(repo, num) { return `https://github.com/${repo}/issues/${num}`; }
            function relUrl(repo, tag) { return `https://github.com/${repo}/releases/tag/${encodeURIComponent(tag)}`; }

            function isoWhen(dstr) {
              return new Date(dstr).toISOString().replace(/\.\d+Z$/, "Z");
            }

            function lineFor(ev) {
              const repo = ev.repo?.name || "";
              const rurl = repoUrl(repo);
              const when = isoWhen(ev.created_at);

              switch (ev.type) {
                case "PullRequestEvent": {
                  const pr = ev.payload?.pull_request;
                  const num = pr?.number ?? ev.payload?.number;
                  let action = ev.payload?.action;
                  if (action === "closed" && pr?.merged) action = "merged";
                  const title = truncate(pr?.title);
                  return `- ${when} ${action} PR [#${num}](${prUrl(repo, num)}) in [${repo}](${rurl})${title ? ` - "${title}"` : ""}`;
                }
                case "PullRequestReviewEvent": {
                  const pr = ev.payload?.pull_request;
                  const num = pr?.number;
                  const state = ev.payload?.review?.state || "reviewed";
                  const title = truncate(pr?.title);
                  return `- ${when} ${state.toLowerCase()} PR [#${num}](${prUrl(repo, num)}) in [${repo}](${rurl})${title ? ` - "${title}"` : ""}`;
                }
                case "PullRequestReviewCommentEvent": {
                  const pr = ev.payload?.pull_request;
                  const num = pr?.number;
                  return `- ${when} commented on PR [#${num}](${prUrl(repo, num)}) in [${repo}](${rurl})`;
                }
                case "IssuesEvent": {
                  const action = ev.payload?.action;
                  const num = ev.payload?.issue?.number;
                  const title = truncate(ev.payload?.issue?.title);
                  return `- ${when} ${action} issue [#${num}](${issueUrl(repo, num)}) in [${repo}](${rurl})${title ? ` - "${title}"` : ""}`;
                }
                case "IssueCommentEvent": {
                  const num = ev.payload?.issue?.number;
                  const title = truncate(ev.payload?.issue?.title);
                  return `- ${when} commented on issue [#${num}](${issueUrl(repo, num)}) in [${repo}](${rurl})${title ? ` - "${title}"` : ""}`;
                }
                case "CommitCommentEvent": {
                  const cid = ev.payload?.comment?.commit_id;
                  const short = cid ? cid.slice(0, 7) : "";
                  return `- ${when} commented on commit [${short}](${rurl}/commit/${cid}) in [${repo}](${rurl})`;
                }
                case "ReleaseEvent": {
                  const tag = ev.payload?.release?.tag_name;
                  const name = truncate(ev.payload?.release?.name);
                  return `- ${when} published release [${tag}](${relUrl(repo, tag)}) in [${repo}](${rurl})${name ? ` - "${name}"` : ""}`;
                }
                case "PushEvent": {
                  const branch = (ev.payload?.ref || "").replace("refs/heads/", "");
                  const count = ev.payload?.commits?.length || 0;
                  const before = ev.payload?.before;
                  const head = ev.payload?.head;
                  const compareUrl = (before && head) ? `${rurl}/compare/${before}...${head}` : rurl;
                  const firstMsg = truncate(ev.payload?.commits?.[0]?.message);
                  return `- ${when} pushed ${count} commit${count === 1 ? "" : "s"} to [${repo}@${branch}](${compareUrl})${firstMsg ? ` - "${firstMsg}"` : ""}`;
                }
                default:
                  return null;
              }
            }

            // Filter, respect lookback window, then limit
            const lines = [];
            for (const ev of events) {
              if (!allowed.has(ev.type)) continue;
              if (new Date(ev.created_at) < cutoff) continue;
              const line = lineFor(ev);
              if (line) lines.push(line);
              if (lines.length >= maxItems) break;
            }

            const block = lines.length ? lines.join("\n") : "- No recent professional activity within the lookback window.";

            // Inject into README
            const fs = require("fs");
            const path = process.env.TARGET_FILE;
            const start = process.env.START_MARKER;
            const end = process.env.END_MARKER;

            let readme = fs.readFileSync(path, "utf8");
            const startIdx = readme.indexOf(start);
            const endIdx = readme.indexOf(end);

            if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
              readme += `\n\n### Latest GitHub Activity\n${start}\n${block}\n${end}\n`;
            } else {
              const before = readme.slice(0, startIdx + start.length);
              const after = readme.slice(endIdx);
              readme = `${before}\n${block}\n${after}`;
            }

            fs.writeFileSync(path, readme);
            core.setOutput("changed", "true");

      - name: Commit and push if changed
        run: |
          if git diff --quiet; then
            echo "No changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${TARGET_FILE}"
          git commit -m "chore(readme): refresh professional activity feed"
          git push
